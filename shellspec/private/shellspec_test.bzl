"""Implementation of the shellspec_test rule.

This rule runs ShellSpec tests against shell scripts and produces
Bazel-compatible test outputs.
"""

load("@bazel_lib//lib:windows_utils.bzl", "create_windows_native_launcher_script")

def _shellspec_test_impl(ctx):
    # Get the ShellSpec files (script + lib files)
    shellspec_files = ctx.files._shellspec_files

    # Find the main shellspec script
    shellspec_script = None
    for f in shellspec_files:
        if f.basename == "shellspec" and f.dirname.endswith("shellspec") or f.short_path.endswith("/shellspec"):
            shellspec_script = f
            break

    if not shellspec_script:
        # Fallback: look for shellspec in the file list
        for f in shellspec_files:
            if f.basename == "shellspec":
                shellspec_script = f
                break

    if not shellspec_script:
        fail("Could not find shellspec script in shellspec_files")

    # Collect all spec files
    spec_files = ctx.files.srcs

    # Generate or use provided .shellspec config file
    if ctx.file.shellspec_config:
        shellspec_config = ctx.file.shellspec_config
    else:
        shellspec_config = ctx.actions.declare_file(ctx.label.name + "_shellspec/.shellspec")
        ctx.actions.write(
            output = shellspec_config,
            content = """# Auto-generated by rules_shellspec for target {label}
# ShellSpec configuration file
# See: https://github.com/shellspec/shellspec#options-file
""".format(
                label = str(ctx.label),
            ),
        )

    # Create the test runner script
    runner_sh = ctx.actions.declare_file(ctx.label.name + "_runner.sh")

    # Build the spec file paths for the runner
    spec_paths = " ".join([f.short_path for f in spec_files])

    # Get additional shellspec options
    shellspec_opts = " ".join(ctx.attr.shellspec_opts)

    # Get the shell to use - use the Bazel-provided bash for cross-platform support
    # If user specified a shell, use that; otherwise leave empty to let the runner
    # use Bazel's bash toolchain
    shell_path = ctx.attr.shell if ctx.attr.shell else ""

    # Compute runfiles keys from short_paths
    # For external repos, short_path is "../<repo>/<path>", runfiles key is "<repo>/<path>"
    # For main repo, short_path is the runfiles key directly
    def _to_runfiles_key(short_path):
        if short_path.startswith("../"):
            return short_path[3:]  # Strip "../"
        return ctx.workspace_name + "/" + short_path

    shellspec_runfiles_key = _to_runfiles_key(shellspec_script.short_path)
    config_runfiles_key = _to_runfiles_key(shellspec_config.short_path)

    # Build spec file runfiles keys
    spec_runfiles_keys = " ".join([_to_runfiles_key(f.short_path) for f in spec_files])

    # Expand the runner template
    ctx.actions.expand_template(
        template = ctx.file._runner_template,
        output = runner_sh,
        substitutions = {
            "{{SHELLSPEC_BIN}}": shellspec_runfiles_key,
            "{{SPEC_FILES}}": spec_runfiles_keys,
            "{{SHELLSPEC_OPTS}}": shellspec_opts,
            "{{SHELL}}": shell_path,
            "{{SHELLSPEC_CONFIG}}": config_runfiles_key,
        },
        is_executable = True,
    )

    # Determine if we're on Windows by checking the platform
    is_windows = ctx.target_platform_has_constraint(ctx.attr._windows_constraint[platform_common.ConstraintValueInfo])

    if is_windows:
        # On Windows, use bazel_lib's launcher script utility
        launcher = create_windows_native_launcher_script(
            ctx,
            shell_script = runner_sh,
        )
        executable = launcher
    else:
        executable = runner_sh

    # Build the complete runfiles - always include the shell script
    generated_files = [shellspec_config, runner_sh]
    runfiles = ctx.runfiles(
        files = spec_files + shellspec_files + ctx.files.data + generated_files,
    )

    # Merge runfiles from dependencies (sh_library, sh_binary targets)
    for dep in ctx.attr.deps:
        runfiles = runfiles.merge(dep[DefaultInfo].default_runfiles)

    # Include the bash runfiles library
    runfiles = runfiles.merge(ctx.attr._runfiles_lib[DefaultInfo].default_runfiles)

    return [
        DefaultInfo(
            executable = executable,
            runfiles = runfiles,
        ),
    ]

shellspec_test = rule(
    implementation = _shellspec_test_impl,
    test = True,
    toolchains = ["@bazel_tools//tools/sh:toolchain_type"],
    attrs = {
        "srcs": attr.label_list(
            allow_files = [".sh"],
            mandatory = True,
            doc = "The ShellSpec spec files to run. These should follow ShellSpec naming conventions (*_spec.sh).",
        ),
        "deps": attr.label_list(
            doc = "Shell library or binary targets that the specs depend on (sh_library, sh_binary).",
        ),
        "data": attr.label_list(
            allow_files = True,
            doc = "Additional data files needed at runtime.",
        ),
        "shell": attr.string(
            default = "",
            doc = """The shell to use for running tests. If empty (the default),
ShellSpec will use its default shell detection. On most systems this is /bin/sh.
Common values: "/bin/bash", "/bin/zsh", "/bin/sh".""",
        ),
        "shellspec_opts": attr.string_list(
            doc = "Additional options to pass to shellspec.",
        ),
        "shellspec_config": attr.label(
            allow_single_file = True,
            doc = "Optional user-provided .shellspec configuration file. If not provided, one will be generated.",
        ),
        "_shellspec_files": attr.label(
            default = "@shellspec//:shellspec_files",
            doc = "All ShellSpec files needed at runtime.",
        ),
        "_runner_template": attr.label(
            default = "//shellspec/private:runner.sh.tpl",
            allow_single_file = True,
            doc = "Template for the test runner script.",
        ),
        "_runfiles_lib": attr.label(
            default = "@bazel_tools//tools/bash/runfiles",
            doc = "The Bazel bash runfiles library.",
        ),
        "_windows_constraint": attr.label(
            default = "@platforms//os:windows",
        ),
    },
    doc = """Runs ShellSpec tests on shell scripts.

This rule executes ShellSpec, a BDD-style testing framework for shell scripts.
It integrates with Bazel's test infrastructure, producing JUnit XML output
for test result reporting.

**Dependencies**: Shell libraries (sh_library) and binaries (sh_binary) in deps
are available in the test's runfiles. You can source them in your spec files
using relative paths from the runfiles root.

**Configuration**: The rule generates a minimal .shellspec configuration file.
You can provide your own via the `shellspec_config` attribute for custom settings.

**Sharding**: This rule does not support test sharding. If sharding is
requested, the test will fail with an appropriate error message.

**Coverage**: ShellSpec requires kcov for coverage reporting. If coverage
is requested but kcov is not installed, a warning will be printed.

Example:
```starlark
load("@rules_shellspec//shellspec:defs.bzl", "shellspec_test")

shellspec_test(
    name = "my_script_test",
    srcs = ["my_script_spec.sh"],
    deps = [":my_script"],
    data = ["test_data.txt"],
)
```
""",
)
