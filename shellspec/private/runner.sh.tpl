#!/usr/bin/env bash
# ShellSpec test runner for Bazel
# This script is generated by the shellspec_test rule.

set -eu

# Ensure HOME is set (shellspec requires it)
# On Windows, HOME might not be set in the bash environment
if [[ -z "${HOME:-}" ]]; then
    if [[ -n "${USERPROFILE:-}" ]]; then
        export HOME="${USERPROFILE}"
    else
        export HOME="${TMPDIR:-/tmp}"
    fi
fi

# =============================================================================
# Sharding Check
# =============================================================================
# ShellSpec does not support Bazel's test sharding mechanism.
# If sharding is enabled, we must fail immediately with a clear error.
if [[ -n "${TEST_TOTAL_SHARDS:-}" ]] && [[ "${TEST_TOTAL_SHARDS}" -gt 1 ]]; then
    echo "ERROR: shellspec_test does not support test sharding." >&2
    echo "ShellSpec runs all specs as a single test suite and cannot partition tests." >&2
    echo "Please remove 'shard_count' from your test target or set it to 1." >&2
    exit 1
fi

# =============================================================================
# Coverage Check
# =============================================================================
# ShellSpec uses kcov for coverage, which is not bundled and requires
# system installation. Warn the user if coverage is requested but kcov
# is not available.
if [[ -n "${COVERAGE:-}" ]] && [[ "${COVERAGE}" == "1" ]]; then
    if ! command -v kcov &>/dev/null; then
        echo "WARNING: Coverage was requested but 'kcov' is not installed." >&2
        echo "ShellSpec requires kcov for shell script coverage reporting." >&2
        echo "Coverage data will not be collected for this test." >&2
        echo "To install kcov, see: https://github.com/SimonKagstrom/kcov" >&2
        echo "" >&2
    fi
fi

# =============================================================================
# Runfiles Setup
# =============================================================================
# Set up the runfiles environment for the bash runfiles library

# --- begin runfiles.bash initialization v3 ---
set -uo pipefail; set +e; f=bazel_tools/tools/bash/runfiles/runfiles.bash
# shellcheck disable=SC1090
source "${RUNFILES_DIR:-/dev/null}/$f" 2>/dev/null || \
  source "$(grep -sm1 "^$f " "${RUNFILES_MANIFEST_FILE:-/dev/null}" | cut -f2- -d' ')" 2>/dev/null || \
  source "$0.runfiles/$f" 2>/dev/null || \
  source "$(grep -sm1 "^$f " "$0.runfiles_manifest" | cut -f2- -d' ')" 2>/dev/null || \
  source "$(grep -sm1 "^$f " "$0.exe.runfiles_manifest" | cut -f2- -d' ')" 2>/dev/null || \
  { echo>&2 "ERROR: cannot find $f"; exit 1; }; f=; set -e
# --- end runfiles.bash initialization v3 ---

# Export runfiles variables so spec_helper.sh can use them
export RUNFILES_DIR
export RUNFILES_MANIFEST_FILE

# =============================================================================
# Path Conversion Helper (for Windows)
# =============================================================================
# On Windows, rlocation may return paths like "D:/path/to/file" which need to
# be converted to Unix-style paths like "/d/path/to/file" for shellspec.
normalize_path() {
    local path="$1"
    # Check if it's a Windows-style path (e.g., D:/... or D:\...)
    if [[ "${path}" =~ ^([A-Za-z]):(.*)$ ]]; then
        local drive="${BASH_REMATCH[1]}"
        local rest="${BASH_REMATCH[2]}"
        # Convert to lowercase drive letter and Unix-style path
        drive="${drive,,}"
        # Replace backslashes with forward slashes
        rest="${rest//\\//}"
        echo "/${drive}${rest}"
    else
        # Not a Windows path, return as-is
        echo "${path}"
    fi
}

# =============================================================================
# Resolve Spec Files First
# =============================================================================
# Resolve spec files and determine their directory.
# We need to cd to the spec directory so relative sourcing works.
SPEC_FILE_KEYS="{{SPEC_FILES}}"
SPEC_FILES=""
SPEC_DIR=""

for key in ${SPEC_FILE_KEYS}; do
    # Resolve via rlocation to get the actual path
    resolved="$(rlocation "${key}")"
    if [[ -z "${resolved}" ]]; then
        echo "ERROR: Could not resolve spec file: ${key}" >&2
        exit 1
    fi
    resolved="$(normalize_path "${resolved}")"

    # Track the directory of spec files (use the first one's directory)
    if [[ -z "${SPEC_DIR}" ]]; then
        SPEC_DIR="$(dirname "${resolved}")"
    fi

    # Store just the filename for running
    SPEC_FILES="${SPEC_FILES} $(basename "${resolved}")"
done

# Change to the spec file directory so relative paths work
# This allows spec files to use `. ./library.sh` to source dependencies
if [[ -n "${SPEC_DIR}" ]] && [[ -d "${SPEC_DIR}" ]]; then
    cd "${SPEC_DIR}"
fi

# =============================================================================
# ShellSpec Config Setup
# =============================================================================
# Create a .shellspec file in the current (spec) directory
SHELLSPEC_CONFIG_KEY="{{SHELLSPEC_CONFIG}}"
SHELLSPEC_CONFIG="$(normalize_path "$(rlocation "${SHELLSPEC_CONFIG_KEY}")")"

if [[ -n "${SHELLSPEC_CONFIG}" ]] && [[ -f "${SHELLSPEC_CONFIG}" ]]; then
    # Copy the generated config to current directory
    cp "${SHELLSPEC_CONFIG}" .shellspec 2>/dev/null || true
else
    # Create a minimal .shellspec if none provided
    touch .shellspec 2>/dev/null || true
fi

# =============================================================================
# Build ShellSpec Arguments
# =============================================================================
SHELLSPEC_ARGS=()

# Set the shell to use (only if explicitly specified)
SHELL_OPT="{{SHELL}}"
if [[ -n "${SHELL_OPT}" ]]; then
    SHELLSPEC_ARGS+=("--shell" "${SHELL_OPT}")
fi

# =============================================================================
# Test Filter Support (--test_filter)
# =============================================================================
# Bazel passes --test_filter value via TEST_FILTER environment variable.
# ShellSpec uses --example (-E) to filter examples by pattern.
if [[ -n "${TEST_FILTER:-}" ]]; then
    SHELLSPEC_ARGS+=("--example" "${TEST_FILTER}")
fi

# Output format and JUnit XML output for Bazel test result integration
# ShellSpec uses -f for display formatter and -o for report output
SHELLSPEC_ARGS+=("--format" "progress")

# If XML_OUTPUT_FILE is set, generate JUnit report to the report directory
if [[ -n "${XML_OUTPUT_FILE:-}" ]]; then
    REPORT_DIR=$(dirname "${XML_OUTPUT_FILE}")
    # Ensure the report directory exists
    mkdir -p "${REPORT_DIR}" 2>/dev/null || true
    SHELLSPEC_ARGS+=("--reportdir" "${REPORT_DIR}")
    SHELLSPEC_ARGS+=("--output" "junit")
fi

# Add any custom shellspec options
CUSTOM_OPTS="{{SHELLSPEC_OPTS}}"
if [[ -n "${CUSTOM_OPTS}" ]]; then
    # shellcheck disable=SC2086
    SHELLSPEC_ARGS+=(${CUSTOM_OPTS})
fi

# =============================================================================
# Execute ShellSpec
# =============================================================================
# Resolve the shellspec binary using rlocation
SHELLSPEC_BIN_KEY="{{SHELLSPEC_BIN}}"
SHELLSPEC_BIN="$(rlocation "${SHELLSPEC_BIN_KEY}")"

if [[ -z "${SHELLSPEC_BIN}" ]]; then
    echo "ERROR: Could not resolve shellspec binary: ${SHELLSPEC_BIN_KEY}" >&2
    exit 1
fi

SHELLSPEC_BIN="$(normalize_path "${SHELLSPEC_BIN}")"

# Run shellspec with the collected arguments
# shellcheck disable=SC2086
exec "${SHELLSPEC_BIN}" "${SHELLSPEC_ARGS[@]}" ${SPEC_FILES}
